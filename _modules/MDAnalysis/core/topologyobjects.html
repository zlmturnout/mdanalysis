<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.core.topologyobjects &mdash; MDAnalysis 0.13.0-dev0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.13.0-dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.13.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.13.0-dev0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.13.0-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.core.topologyobjects</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core Topology Objects --- :mod:`MDAnalysis.core.topologyobjects`</span>
<span class="sd">================================================================</span>

<span class="sd">The building blocks for MDAnalysis&#39; description of topology</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..lib.mdamath</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">dihedral</span>
<span class="kn">from</span> <span class="nn">..lib.mdamath</span> <span class="kn">import</span> <span class="n">angle</span> <span class="k">as</span> <span class="n">slowang</span>
<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="kn">import</span> <span class="n">cached</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">distances</span>

<div class="viewcode-block" id="TopologyObject"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject">[docs]</a><span class="k">class</span> <span class="nc">TopologyObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for all Topology items.</span>

<span class="sd">    Defines the behaviour by which Bonds/Angles/etc in MDAnalysis should</span>
<span class="sd">    behave.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       All TopologyObject now keep track of if they were guessed or not</span>
<span class="sd">       via the ``is_guessed`` managed property.</span>
<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">       Added the `value` method to return the size of the object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;atoms&quot;</span><span class="p">,</span> <span class="s">&quot;_is_guessed&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">is_guessed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_guessed</span> <span class="o">=</span> <span class="n">is_guessed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple of indices describing this object</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Type of the bond as a tuple</span>

<span class="sd">        When comparing types, it is important to consider the reverse</span>
<span class="sd">        of the type too, i.e.::</span>

<span class="sd">            a.type == b.type or a.type == b.type[::-1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c"># is property so it gets nice docs?</span>
        <span class="sd">&quot;&quot;&quot;``True`` if the bond was guessed.</span>

<span class="sd">        .. SeeAlso:: :func:`guess_bonds` :func:`guess_angles` and</span>
<span class="sd">                     :func:`guess_dihedrals`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_guessed</span>

    <span class="nd">@is_guessed.setter</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_guessed</span> <span class="o">=</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;{cname} between: {conts}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">cname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="n">conts</span><span class="o">=</span><span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
                <span class="s">&quot;Atom {num} ({name} of {resname}-{resid})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">num</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">resname</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span>
                    <span class="n">resid</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]))</span>

<div class="viewcode-block" id="TopologyObject.__contains__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether an atom is in this :class:`TopologyObject`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
</div>
<div class="viewcode-block" id="TopologyObject.__eq__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether two bonds have identical contents&quot;&quot;&quot;</span>
        <span class="n">my_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
        <span class="n">ot_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">my_tup</span> <span class="o">==</span> <span class="n">ot_tup</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">my_tup</span> <span class="o">==</span> <span class="n">ot_tup</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</div>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>  <span class="c"># so bondlists can be sorted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span>

<div class="viewcode-block" id="TopologyObject.__getitem__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Can retrieve a given Atom from within&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Bond"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond">[docs]</a><span class="k">class</span> <span class="nc">Bond</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A bond between two :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    Two :class:`Bond` instances can be compared with the ``==`` and</span>
<span class="sd">    ``!=`` operators. A bond is equal to another if the same atom</span>
<span class="sd">    numbers are connected and they have the same bond order. The</span>
<span class="sd">    ordering of the two atom numbers is ignored as is the fact that a</span>
<span class="sd">    bond was guessed.</span>

<span class="sd">    The presence of a particular atom can also be queried::</span>

<span class="sd">      &gt;&gt;&gt; Atom in Bond</span>

<span class="sd">    will return either ``True`` or ``False``.</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`. Changed class to use</span>
<span class="sd">       :attr:`__slots__` and stores atoms in :attr:`atoms` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;atoms&quot;</span><span class="p">,</span> <span class="s">&quot;order&quot;</span><span class="p">,</span> <span class="s">&quot;_is_guessed&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_guessed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_guessed</span> <span class="o">=</span> <span class="n">is_guessed</span>

<div class="viewcode-block" id="Bond.partner"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond.partner">[docs]</a>    <span class="k">def</span> <span class="nf">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bond.partner(Atom)</span>

<span class="sd">        :Returns: the other :class:`~MDAnalysis.core.AtomGroup.Atom` in this</span>
<span class="sd">                  bond</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">atom</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unrecognised Atom&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Bond.length"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the bond.</span>

<span class="sd">        .. versionchanged:: 0.11.0</span>
<span class="sd">           Added pbc keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">self_distance_array</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">]),</span>
                <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
</div>
    <span class="n">value</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">s_id</span> <span class="o">=</span> <span class="s">&quot;&lt;Bond between: Atom {0:d} ({1.name} of {1.resname} {1.resid}&quot;</span>\
               <span class="s">&quot; {1.altLoc}) and Atom {2:d} ({3.name} of {3.resname}&quot;</span>\
               <span class="s">&quot;{3.resid} {3.altLoc})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">a1</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s_length</span> <span class="o">=</span> <span class="s">&quot;, length {0:.2f} A&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">s_length</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>  <span class="c"># no trajectory/coordinates available</span>
        <span class="k">return</span> <span class="n">s_id</span> <span class="o">+</span> <span class="n">s_length</span> <span class="o">+</span> <span class="s">&quot;&gt;&quot;</span>

</div>
<div class="viewcode-block" id="Angle"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Angle">[docs]</a><span class="k">class</span> <span class="nc">Angle</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;An angle between three :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>
<span class="sd">    Atom 2 is the apex of the angle</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`; now uses</span>
<span class="sd">       :attr:`__slots__` and stores atoms in :attr:`atoms` attribute</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Angle.angle"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Angle.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the angle in degrees of this Angle.</span>

<span class="sd">        Angle between atoms 0 and 2 with apex at 1::</span>

<span class="sd">              2</span>
<span class="sd">             /</span>
<span class="sd">            /</span>
<span class="sd">           1------0</span>

<span class="sd">        .. Note:: The numerical precision is typically not better than</span>
<span class="sd">                  4 decimals (and is only tested to 3 decimals).</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
</div>
    <span class="n">value</span> <span class="o">=</span> <span class="n">angle</span>

</div>
<div class="viewcode-block" id="Dihedral"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Dihedral">[docs]</a><span class="k">class</span> <span class="nc">Dihedral</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Dihedral (dihedral angle) between four</span>
<span class="sd">    :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    The dihedral is defined as the angle between the planes formed by</span>
<span class="sd">    Atoms (1, 2, 3) and (2, 3, 4).</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`; now uses :attr:`__slots__` and</span>
<span class="sd">       stores atoms in :attr:`atoms` attribute.</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Renamed to Dihedral (was Torsion)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># http://cbio.bmt.tue.nl/pumma/uploads/Theory/dihedral.png</span>

<div class="viewcode-block" id="Dihedral.dihedral"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Dihedral.dihedral">[docs]</a>    <span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the dihedral angle in degrees.</span>

<span class="sd">        Dihedral angle around axis connecting atoms 1 and 2 (i.e. the angle</span>
<span class="sd">        between the planes spanned by atoms (0,1,2) and (1,2,3))::</span>

<span class="sd">                  3</span>
<span class="sd">                  |</span>
<span class="sd">            1-----2</span>
<span class="sd">           /</span>
<span class="sd">          0</span>


<span class="sd">        .. Note:: The numerical precision is typically not better than</span>
<span class="sd">                  4 decimals (and is only tested to 3 decimals).</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">B</span><span class="o">.</span><span class="n">position</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">C</span><span class="o">.</span><span class="n">position</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">D</span><span class="o">.</span><span class="n">position</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dihedral</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">))</span>
</div>
    <span class="n">value</span> <span class="o">=</span> <span class="n">dihedral</span>

</div>
<div class="viewcode-block" id="ImproperDihedral"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.ImproperDihedral">[docs]</a><span class="k">class</span> <span class="nc">ImproperDihedral</span><span class="p">(</span><span class="n">Dihedral</span><span class="p">):</span>  <span class="c"># subclass Dihedral to inherit dihedral method</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Improper Dihedral (improper dihedral angle) between four</span>
<span class="sd">    :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    MDAnalysis treats the improper dihedral angle as the angle between</span>
<span class="sd">    the planes formed by Atoms (1, 2, 3) and (2, 3, 4).</span>

<span class="sd">    .. warning:: Definitions of Atom ordering in improper dihedrals</span>
<span class="sd">                 can change. Check the definitions here against</span>
<span class="sd">                 your software.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Renamed to ImproperDihedral (was Improper_Torsion)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># http://cbio.bmt.tue.nl/pumma/uploads/Theory/improper.png</span>

<div class="viewcode-block" id="ImproperDihedral.improper"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.ImproperDihedral.improper">[docs]</a>    <span class="k">def</span> <span class="nf">improper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Improper dihedral angle in degrees.</span>

<span class="sd">        .. Note:: The numerical precision is typically not better than</span>
<span class="sd">                  4 decimals (and is only tested to 3 decimals).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="TopologyDict"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict">[docs]</a><span class="k">class</span> <span class="nc">TopologyDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A customised dictionary designed for sorting the bonds, angles and</span>
<span class="sd">    dihedrals present in a group of atoms.</span>

<span class="sd">    Usage::</span>

<span class="sd">      topologydict = TopologyDict(members)</span>

<span class="sd">    :Arguments:</span>
<span class="sd">        *members*</span>
<span class="sd">            A list of :class:`TopologyObject` instances</span>

<span class="sd">    :Returns:</span>
<span class="sd">        *topologydict*</span>
<span class="sd">            A specialised dictionary of the topology instances passed to it</span>

<span class="sd">    TopologyDicts are also built lazily from a :class:`TopologyGroup.topDict`</span>
<span class="sd">    attribute.</span>

<span class="sd">    The :class:`TopologyDict` collects all the selected topology type from the</span>
<span class="sd">    atoms and categorises them according to the types of the atoms within.</span>
<span class="sd">    A :class:`TopologyGroup` containing all of a given bond type can</span>
<span class="sd">    be made by querying with the appropriate key.  The keys to the</span>
<span class="sd">    :class:`TopologyDict` are a tuple of the atom types that the bond represents</span>
<span class="sd">    and can be viewed using the :meth:`keys` method.</span>

<span class="sd">    For example, from a system containing pure ethanol ::</span>

<span class="sd">      &gt;&gt;&gt; td = u.bonds.topDict</span>
<span class="sd">      &gt;&gt;&gt; td.keys()</span>
<span class="sd">      [(&#39;C&#39;, &#39;C&#39;),</span>
<span class="sd">       (&#39;C&#39;, &#39;H&#39;),</span>
<span class="sd">       (&#39;O&#39;, &#39;H&#39;),</span>
<span class="sd">       (&#39;C&#39;, &#39;O&#39;)]</span>
<span class="sd">      &gt;&gt;&gt; td[&#39;C&#39;, &#39;O&#39;]</span>
<span class="sd">      &lt; TopologyGroup containing 912 bonds &gt;</span>

<span class="sd">    .. Note::</span>

<span class="sd">       The key for a bond is taken from the type attribute of the atoms.</span>

<span class="sd">       Getting and setting types of bonds is done smartly, so a C-C-H</span>
<span class="sd">       angle is considered identical to a H-C-C angle.</span>

<span class="sd">    Duplicate entries are automatically removed upon creation and</span>
<span class="sd">    combination of different Dicts.  This means a bond between atoms</span>
<span class="sd">    1 and 2 will only ever appear once in a dict despite both atoms 1</span>
<span class="sd">    and 2 having the bond in their :attr:`bond` attribute.</span>

<span class="sd">    Two :class:`TopologyDict` instances can be combined using</span>
<span class="sd">    addition and it will not create any duplicate bonds in the process.</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Changed initialisation to use a list of :class:`TopologyObject`</span>
<span class="sd">       instances instead of list of atoms; now used from within</span>
<span class="sd">       :class:`TopologyGroup` instead of accessed from :class:`AtomGroup`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c"># Detect what I&#39;ve been given</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TopologyObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">=</span> <span class="n">members</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># Throw error if not given right thing</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Unrecognised input&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">type</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_removeDupes</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_removeDupes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sorts through contents and makes sure that there are no duplicate keys</span>
<span class="sd">        (through type reversal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c"># Go through all keys, if the reverse of the key exists add this to</span>
        <span class="c"># that entry else make a new entry</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">newdict</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="n">newdict</span>

<div class="viewcode-block" id="TopologyDict.__len__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of types of bond in the topology dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="TopologyDict.keys"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of the different types of available bonds&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="TopologyDict.__iter__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over keys in this dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;TopologyDict with {num} unique {type}s&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">toptype</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyDict.__getitem__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a TopologyGroup matching the criteria if possible,</span>
<span class="sd">        otherwise returns ``None``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TopologyDict.__contains__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns boolean on whether a given type exists within this dictionary</span>

<span class="sd">        For topology groups the key (1,2,3) is considered the same as (3,2,1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="ow">or</span> <span class="n">other</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span>

</div></div>
<div class="viewcode-block" id="TopologyGroup"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup">[docs]</a><span class="k">class</span> <span class="nc">TopologyGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A container for a groups of bonds.</span>

<span class="sd">    All bonds of a certain types can be retrieved from within the</span>
<span class="sd">    :class:`TopologyGroup` by querying with a tuple of types::</span>

<span class="sd">      tg2 = tg.select_bonds([key])</span>

<span class="sd">    Where *key* describes the desired bond as a tuple of the involved</span>
<span class="sd">    :class:`~MDAnalysis.AtomGroup.Atom` types, as defined by the .type Atom</span>
<span class="sd">    attribute). A list of available keys can be displayed using the</span>
<span class="sd">    :meth:`types` method.</span>

<span class="sd">    Alternatively, all the bonds which are in a given</span>
<span class="sd">    :class:`~MDAnalysis.AtomGroup.AtomGroup` can be extracted using</span>
<span class="sd">    :meth:`atomgroup_intersection`::</span>

<span class="sd">      tg2 = tg.atomgroup_intersection(ag)</span>

<span class="sd">    This allows the keyword *strict* to be given, which forces all members of</span>
<span class="sd">    all bonds to be inside the AtomGroup passed to it.</span>

<span class="sd">    Finally, a TopologyGroup can be sliced similarly to AtomGroups::</span>

<span class="sd">      tg2 = tg[5:10]</span>

<span class="sd">    The :meth:`bonds`, :meth:`angles` and :meth:`dihedrals` methods offer</span>
<span class="sd">    a &quot;shortcut&quot; to the Cython distance calculation functions in</span>
<span class="sd">    :class:`MDAnalysis.lib.distances`.</span>

<span class="sd">    TopologyGroups can be combined with TopologyGroups of the same bond</span>
<span class="sd">    type (ie can combine two angle containing TopologyGroups).</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Overhauled completely: (1) Added internal :class:`TopologyDict`</span>
<span class="sd">       accessible by the :attr:`topDict` attribute. (2)</span>
<span class="sd">       :meth:`selectBonds` allows the :attr:`topDict` to be queried</span>
<span class="sd">       with tuple of types. (3) Added :meth:`atomgroup_intersection`</span>
<span class="sd">       to allow bonds which are in a given :class:`AtomGroup` to be retrieved.</span>
<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       Added :func:`from_indices` constructor, allowing class to be created</span>
<span class="sd">       from indices.</span>
<span class="sd">       Can now create empty Group.</span>
<span class="sd">       Renamed :meth:`dump_contents` to :meth:`to_indices`</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Added `values` method to return the size of each object in this group</span>
<span class="sd">       Deprecated selectBonds method in favour of select_bonds</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">=</span> <span class="n">bondlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># only check type if list has length</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bondlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TopologyObject</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Input must be TopologyObject&quot;</span><span class="p">)</span>
        <span class="c"># Would be nice to make everything work internally using sets, BUT</span>
        <span class="c"># sets can&#39;t be indexed, so couldn&#39;t work backward from .angles()</span>
        <span class="c"># results to find which angle is a certain value.</span>
        <span class="c"># Sorted so that slicing returns sensible results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bondlist</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c"># used for topdict saving</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TopologyGroup.from_indices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.from_indices">[docs]</a>    <span class="k">def</span> <span class="nf">from_indices</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">,</span> <span class="n">atomgroup</span><span class="p">,</span>
                     <span class="n">bondclass</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                     <span class="n">remove_duplicates</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initiate from a list of indices.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *bondlist*</span>
<span class="sd">            A list of lists of indices.  For example `[(0, 1), (1, 2)]`</span>
<span class="sd">            Note that these indices refer to the index of the Atoms</span>
<span class="sd">            within the supplied AtomGroup, not their global index.</span>
<span class="sd">          *atomgroup*</span>
<span class="sd">            An AtomGroup which the indices from bondlist will be used on.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *bondclass*</span>
<span class="sd">            The Class of the topology object to be made.</span>
<span class="sd">            If missing this will try and be guessed according to the number</span>
<span class="sd">            of indices in each record.</span>
<span class="sd">          *guessed*</span>
<span class="sd">            Whether or not the bonds were guessed. [``True``]</span>
<span class="sd">          *remove_duplicates*</span>
<span class="sd">            Sort through items and make sure that no duplicates are created [``False``]</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">remove_duplicates</span><span class="p">:</span>
            <span class="c"># always have first index less than last</span>
            <span class="n">bondlist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">b</span> <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bondlist</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">bondclass</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># try and guess</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bondclass</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="mi">2</span><span class="p">:</span><span class="n">Bond</span><span class="p">,</span>
                    <span class="mi">3</span><span class="p">:</span><span class="n">Angle</span><span class="p">,</span>
                    <span class="mi">4</span><span class="p">:</span><span class="n">Dihedral</span>
                <span class="p">}[</span><span class="nb">len</span><span class="p">(</span><span class="n">bondlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Can&#39;t detect bondclass for provided indices&quot;</span><span class="p">)</span>

        <span class="n">bonds</span> <span class="o">=</span> <span class="p">[</span><span class="n">bondclass</span><span class="p">([</span><span class="n">atomgroup</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">],</span> <span class="n">is_guessed</span><span class="o">=</span><span class="n">guessed</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">bondlist</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TopologyGroup.select_bonds"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.select_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">select_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a selection from this topology group based on types.</span>

<span class="sd">        .. seeAlso :meth:`types`</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topDict</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>
</div>
    <span class="n">selectBonds</span> <span class="o">=</span> <span class="n">select_bonds</span>

<div class="viewcode-block" id="TopologyGroup.types"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.types">[docs]</a>    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the bond types in this TopologyGroup</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;dict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">topDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the TopologyDict for this topology group.</span>

<span class="sd">        This is used for the select_bonds method when fetching a certain type</span>
<span class="sd">        of bond.</span>

<span class="sd">        This is a cached property so will be generated the first time it is</span>
<span class="sd">        accessed.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TopologyDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyGroup.atomgroup_intersection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.atomgroup_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">atomgroup_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve all bonds from within this TopologyGroup that are within</span>
<span class="sd">        the AtomGroup which is passed.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *strict*</span>
<span class="sd">            Only retrieve bonds which are completely contained within the</span>
<span class="sd">            AtomGroup. [``False``]</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;strict&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strict_intersection</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loose_intersection</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_loose_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies bonds if it appears even once in an AtomGroup</span>

<span class="sd">        This means that some bonds might extend out of the defined AtomGroup</span>

<span class="sd">        .. SeeAlso:: :meth:`_strict_intersection` for including bonds</span>
<span class="sd">                     more strictly</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="n">other_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="n">other_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Dihedral&#39;</span><span class="p">:</span>
            <span class="n">other_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;ImproperDihedral&#39;</span><span class="p">:</span>
            <span class="n">other_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">impropers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unsupported intersection&quot;</span><span class="p">)</span>

        <span class="n">newlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other_set</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">newlist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_strict_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies bonds only if all members of the bond appear in the AtomGroup</span>

<span class="sd">        This means that all bonds will be contained within the AtomGroup</span>

<span class="sd">        .. SeeAlso:: :meth:`_loose_intersection` for including bonds</span>
<span class="sd">                     less strictly</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create a dictionary of all bonds within this TG, initialised to 0</span>
        <span class="c"># for each</span>
        <span class="c">#</span>
        <span class="c"># Then go through all TopObjs in AtomGroup and count their appearances</span>
        <span class="c"># keeping track using the dict</span>
        <span class="c">#</span>
        <span class="c"># Then see how many times each TopObj was spotted in the AtomGroup&#39;s bonds</span>
        <span class="c">#</span>
        <span class="c"># If this count is equal to crit, (bond=2, angle=3, dihedral=4) then</span>
        <span class="c"># the TopObj was seen enough for it to have to be completely be</span>
        <span class="c"># present in the AtomGroup</span>

        <span class="c"># each bond starts with 0 appearances</span>
        <span class="c"># I&#39;m only interested in intersection, so if its not in tg then</span>
        <span class="c"># i&#39;ll get keyerrors which i&#39;ll pass</span>
        <span class="n">count_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c"># then go through ag and count appearances of bonds</span>
<span class="c"># This seems to benchmark slow, because __getattribute__ is slower than a.bonds</span>
<span class="c">#        for atom in other:</span>
<span class="c">#            for b in atom.__getattribute__(req_attr):</span>
<span class="c">#                try:</span>
<span class="c">#                    count_dict[b] += 1</span>
<span class="c">#                except KeyError:  # if he&#39;s not in dict then meh</span>
<span class="c">#                    pass</span>
<span class="c"># So I&#39;ll bruteforce here, despite it being fugly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">angles</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Dihedral&#39;</span><span class="p">:</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;ImproperDihedral&#39;</span><span class="p">:</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">impropers</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>

        <span class="c"># now make new list, which only includes bonds with enough appearances</span>
        <span class="n">newlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span> <span class="k">if</span> <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="n">crit</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">newlist</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyGroup.to_indices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.to_indices">[docs]</a>    <span class="k">def</span> <span class="nf">to_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of tuples which define the contents of this</span>
<span class="sd">        TopologyGroup in terms of the atom numbers,</span>
<span class="sd">        (0 based index within u.atoms)</span>

<span class="sd">        This format should be identical to the original contents of the</span>
<span class="sd">        entries in universe._topology.</span>
<span class="sd">        Note that because bonds are sorted as they are initialised, the order</span>
<span class="sd">        that atoms are defined in each entry might be reversed.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Renamed from &quot;dump_contents&quot; to &quot;to_indices&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># should allow topology information to be pickled even if it is</span>
        <span class="c"># substantially changed from original input,</span>
        <span class="c"># eg through merging universes or defining new bonds manually.</span>
        <span class="n">bondlist</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">indices</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">bondlist</span>
</div>
    <span class="n">dump_contents</span> <span class="o">=</span> <span class="n">to_indices</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;atom1&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atom1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.AtomGroup</span> <span class="kn">import</span> <span class="n">AtomGroup</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;atom2&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atom2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.AtomGroup</span> <span class="kn">import</span> <span class="n">AtomGroup</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;atom3&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atom3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.AtomGroup</span> <span class="kn">import</span> <span class="n">AtomGroup</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;atom4&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atom4</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.AtomGroup</span> <span class="kn">import</span> <span class="n">AtomGroup</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

<div class="viewcode-block" id="TopologyGroup.__len__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of bonds in the topology group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TopologyGroup.__add__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two TopologyGroups together.</span>

<span class="sd">        Can combined two TopologyGroup of the same type, or add a single</span>
<span class="sd">        TopologyObject to a TopologyGroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># check addition is sane</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyObject</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyGroup</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Can only combine TopologyObject or TopologyGroup to&quot;</span>
                            <span class="s">&quot; TopologyGroup, not {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

        <span class="c"># cases where either other or self is empty TG</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>  <span class="c"># adding empty TG to me</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyObject</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">([</span><span class="n">other</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>

        <span class="c"># add TO to me</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyObject</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Cannot add different types of &quot;</span>
                                <span class="s">&quot;TopologyObjects together&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span> <span class="o">+</span> <span class="p">(</span><span class="n">other</span><span class="p">,))</span>

        <span class="c"># add TG to me</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">toptype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Can only combine TopologyGroups of the same type&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TopologyGroup.__getitem__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a particular bond as single object or a subset of</span>
<span class="sd">        this TopologyGroup as another TopologyGroup</span>

<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Allows indexing via boolean numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>  <span class="c"># single TopObj</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>  <span class="c"># new TG</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">))[</span><span class="n">item</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c"># zero length item</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">item</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="TopologyGroup.__iter__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over all bonds&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TopologyGroup.__contains__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if this TopologyGroup contains a bond&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;TopologyGroup containing {num} {type}s&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">toptype</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyGroup.__eq__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if contents of TopologyGroups are equal&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c"># Distance calculation methods below</span>
    <span class="c"># &quot;Slow&quot; versions exist as a way of testing the Cython implementations</span>
<div class="viewcode-block" id="TopologyGroup.values"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the size of each object in this Group</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating distance</span>
<span class="sd">              [``False``]</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used,</span>
<span class="sd">              note that this will be overwritten</span>

<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Dihedral&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;ImproperDihedral&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_bondsSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of bond (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Bond&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bond_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span>
            <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
                <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">dimensions</span>
                <span class="c"># orthogonal and divide by zero check</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">bond_dist</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">bond_dist</span> <span class="o">/</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Only orthogonal boxes supported&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">bond_dist</span><span class="p">])</span>

<div class="viewcode-block" id="TopologyGroup.bonds"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.bonds">[docs]</a>    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the distance between all bonds in this TopologyGroup</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating distance</span>
<span class="sd">              [False]</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used,</span>
<span class="sd">              note that this will be overwritten</span>

<span class="sd">        Uses cython implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Bond&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                        <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                        <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                        <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_anglesSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of angle (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Angle&#39;&quot;</span><span class="p">)</span>

        <span class="n">vec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">vec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">slowang</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">angles</span>

<div class="viewcode-block" id="TopologyGroup.angles"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.angles">[docs]</a>    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the angle in radians formed between a bond</span>
<span class="sd">        between atoms 1 and 2 and a bond between atoms 2 &amp; 3</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used, note that this</span>
<span class="sd">              will be overwritten</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating angles</span>
<span class="sd">              [``False``] this is important when connecting vectors between atoms</span>
<span class="sd">              might require minimum image convention</span>

<span class="sd">        Uses cython implementation</span>

<span class="sd">        .. versionchanged :: 0.9.0</span>
<span class="sd">           Added *pbc* option (default ``False``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Angle&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                         <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_dihedralsSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of dihedral (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;Dihedral&#39;</span><span class="p">,</span> <span class="s">&#39;ImproperDihedral&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Dihedral&#39; or &quot;</span>
                            <span class="s">&quot;&#39;ImproperDihedral&#39;&quot;</span><span class="p">)</span>

        <span class="n">vec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">vec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">vec3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom4</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">positions</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dihedral</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">vec3</span><span class="p">)])</span>

<div class="viewcode-block" id="TopologyGroup.dihedrals"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.dihedrals">[docs]</a>    <span class="k">def</span> <span class="nf">dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the dihedralal angle in radians for this topology</span>
<span class="sd">        group.</span>

<span class="sd">        Defined as the angle between a plane formed by atoms 1, 2 and</span>
<span class="sd">        3 and a plane formed by atoms 2, 3 and 4.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used, note that this</span>
<span class="sd">              will be overwritten</span>
<span class="sd">           *pbc*</span>
<span class="sd">v              apply periodic boundary conditions when calculating angles</span>
<span class="sd">              [``False``] this is important when connecting vectors between</span>
<span class="sd">              atoms might require minimum image convention</span>

<span class="sd">        Uses cython implementation.</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Added *pbc* option (default ``False``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;Dihedral&#39;</span><span class="p">,</span> <span class="s">&#39;ImproperDihedral&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Dihedral&#39; or &quot;</span>
                            <span class="s">&quot;&#39;ImproperDihedral&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atom4</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                            <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atom4</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.13.0-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua
    Adelman, Jonathan Barnoud, Christian Beckstein (logo), Alejandro
    Bernardin, Sbastien Buchoux, David Caplan, Matthieu Chavent,
    Xavier Deupi, Jan Domaski, David L. Dotson, Lennard van der
    Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas
    Grossar, Benjamin Hall, Joe Jordan, Max Linke, Jinju Lu, Robert
    McGibbon, Alex Nesterenko, Manuel Nuno Melo, Caio S. Souza, Danny
    Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Sean
    L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac
    Virshup, Zhuyi Xue, Carlos Yez S., and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>